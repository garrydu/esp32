/**
  ESP32s3 adaptation by Tyeth Gundry of Arduino version of
  First demo for FT6206 Capactive Touch Screen on Wokwi. Enjoy!

  https://wokwi.com/arduino/projects/311598148845830720
 */

/***************************************************
  This is our touchscreen painting example for the Adafruit ILI9341
  captouch shield
  ----> http://www.adafruit.com/products/1947

  Check out the links above for our tutorials and wiring diagrams

  Adafruit invests time and resources providing this open source code,
  please support Adafruit and open-source hardware by purchasing
  products from Adafruit!

  Written by Limor Fried/Ladyada for Adafruit Industries.
  MIT license, all text above must be included in any redistribution
 ****************************************************/

// #include <Adafruit_GFX.h> // Core graphics library
// #include <SPI.h>          // this is needed for display

// #include <Adafruit_ILI9341.h>
#include <Arduino.h> // this is needed for FT6206
#include <Adafruit_FT6206.h>

// // #define LV_CONF_INCLUDE_SIMPLE 1
// #ifndef LV_CONF_INCLUDE_SIMPLE
// #define LV_CONF_INCLUDE_SIMPLE 1
// #endif

// #define LV_CONF_INCLUDE_SIMPLE
// #include "lv_conf.h"
#include <lvgl.h>
// #include <lv_tft_espi.h>
// #include <TFT_eSPI.h>
// #define LV_USE_TFT_ESPI 1
// #include "../lib/lvgl-9.3.0/src/drivers/display/tft_espi/lv_tft_espi.h"

// The FT6206 uses hardware I2C (SCL/SDA)
Adafruit_FT6206 ctp = Adafruit_FT6206();
Adafruit_FT6206 touchscreen = ctp;

// #define TFT_DC D0
// #define TFT_CS D1
// Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC);

// Set resolution defines if not in lv_conf.h
// #ifndef LV_HOR_RES_MAX
// #define LV_HOR_RES_MAX 320
// #endif
// #ifndef LV_VER_RES_MAX
// #define LV_VER_RES_MAX 240
// #endif

#define SCREEN_WIDTH 240
#define SCREEN_HEIGHT 320

// Touchscreen coordinates: (x, y) and pressure (z)
int x, y, z;

// buffers for LVGL drawing (double buffering)
#define DRAW_BUF_SIZE (SCREEN_WIDTH * SCREEN_HEIGHT / 10 * (LV_COLOR_DEPTH / 8))
uint32_t draw_buf[DRAW_BUF_SIZE / 4];
// static lv_disp_draw_buf_t draw_buf;
// static lv_color_t buf[LV_HOR_RES_MAX * 10]; // Adjust size for your screen/draw area

// If logging is enabled, it will inform the user about what is happening in the library
// void log_print(lv_log_level_t level, const char *buf)
// {
//   LV_UNUSED(level);
//   Serial.println(buf);
//   Serial.flush();
// }

// Get the Touchscreen data
// void touchscreen_read(lv_indev_t *indev, lv_indev_data_t *data)
// {
//   // Checks if Touchscreen was touched, and prints X, Y and Pressure (Z)
//   if (touchscreen.touched())
//   {
//     // Get Touchscreen points
//     TS_Point p = touchscreen.getPoint();
//     // Calibrate Touchscreen points with map function to the correct width and height
//     // flip it around to match the screen.
//     x = map(p.x, 0, 240, 240, 0);
//     y = map(p.y, 0, 320, 320, 0);
//     z = p.z;

//     data->state = LV_INDEV_STATE_PRESSED;

//     // Set the coordinates
//     data->point.x = x;
//     data->point.y = y;
//   }
//   else
//   {
//     data->state = LV_INDEV_STATE_RELEASED;
//   }
// }

void touchscreen_read(lv_indev_t *indev, lv_indev_data_t *data)
{
  if (touchscreen.touched())
  {
    TS_Point p = touchscreen.getPoint();
    data->point.x = p.x;
    data->point.y = p.y;
    data->state = LV_INDEV_STATE_PR;
  }
  else
  {
    data->state = LV_INDEV_STATE_REL;
  }
}

int btn1_count = 0;
// Callback that is triggered when btn1 is clicked
static void event_handler_btn1(lv_event_t *e)
{
  lv_event_code_t code = lv_event_get_code(e);
  if (code == LV_EVENT_CLICKED)
  {
    btn1_count++;
    // LV_LOG_USER("Button clicked %d", (int)btn1_count);
  }
}

// Callback that is triggered when btn2 is clicked/toggled
static void event_handler_btn2(lv_event_t *e)
{
  lv_event_code_t code = lv_event_get_code(e);
  lv_obj_t *obj = (lv_obj_t *)lv_event_get_target(e);
  if (code == LV_EVENT_VALUE_CHANGED)
  {
    LV_UNUSED(obj);
    // LV_LOG_USER("Toggled %s", lv_obj_has_state(obj, LV_STATE_CHECKED) ? "on" : "off");
  }
}

static lv_obj_t *slider_label;
// Callback that prints the current slider value on the TFT display and Serial Monitor for debugging purposes
static void slider_event_callback(lv_event_t *e)
{
  lv_obj_t *slider = (lv_obj_t *)lv_event_get_target(e);
  char buf[8];
  lv_snprintf(buf, sizeof(buf), "%d%%", (int)lv_slider_get_value(slider));
  lv_label_set_text(slider_label, buf);
  lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);
  // LV_LOG_USER("Slider changed to %d%%", (int)lv_slider_get_value(slider));
}

void lv_create_main_gui(void)
{
  // Create a text label aligned center on top ("Hello, world!")
  lv_obj_t *text_label = lv_label_create(lv_screen_active());
  lv_label_set_long_mode(text_label, LV_LABEL_LONG_WRAP); // Breaks the long lines
  lv_label_set_text(text_label, "Hello, world!");
  lv_obj_set_width(text_label, 150); // Set smaller width to make the lines wrap
  lv_obj_set_style_text_align(text_label, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_align(text_label, LV_ALIGN_CENTER, 0, -90);

  lv_obj_t *btn_label;
  // Create a Button (btn1)
  lv_obj_t *btn1 = lv_button_create(lv_screen_active());
  lv_obj_add_event_cb(btn1, event_handler_btn1, LV_EVENT_ALL, NULL);
  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, -50);
  lv_obj_remove_flag(btn1, LV_OBJ_FLAG_PRESS_LOCK);

  btn_label = lv_label_create(btn1);
  lv_label_set_text(btn_label, "Button");
  lv_obj_center(btn_label);

  // Create a Toggle button (btn2)
  lv_obj_t *btn2 = lv_button_create(lv_screen_active());
  lv_obj_add_event_cb(btn2, event_handler_btn2, LV_EVENT_ALL, NULL);
  lv_obj_align(btn2, LV_ALIGN_CENTER, 0, 10);
  lv_obj_add_flag(btn2, LV_OBJ_FLAG_CHECKABLE);
  lv_obj_set_height(btn2, LV_SIZE_CONTENT);

  btn_label = lv_label_create(btn2);
  lv_label_set_text(btn_label, "Toggle");
  lv_obj_center(btn_label);

  // Create a slider aligned in the center bottom of the TFT display
  lv_obj_t *slider = lv_slider_create(lv_screen_active());
  lv_obj_align(slider, LV_ALIGN_CENTER, 0, 60);
  lv_obj_add_event_cb(slider, slider_event_callback, LV_EVENT_VALUE_CHANGED, NULL);
  lv_slider_set_range(slider, 0, 100);
  lv_obj_set_style_anim_duration(slider, 2000, 0);

  // Create a label below the slider to display the current slider value
  slider_label = lv_label_create(lv_screen_active());
  lv_label_set_text(slider_label, "0%");
  lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);
}

void setup(void)
{
  // Initialize serial communication
  Serial.begin(115200);
  while (!Serial)
    ; // used for leonardo debugging
  String LVGL_Arduino = String("LVGL Library Version: ") + lv_version_major() + "." + lv_version_minor() + "." + lv_version_patch();
  Serial.println(LVGL_Arduino);
  Serial.print("PSRAM Size: ");
  Serial.println(ESP.getPsramSize());

  // tft.begin();

  if (!ctp.begin(40))
  { // pass in 'sensitivity' coefficient
    Serial.println("Couldn't start FT6206 touchscreen controller");
    while (1)
      ;
  }

  Serial.println("Capacitive touchscreen started");

  // Start LVGL
  lv_init();
  // Register print function for debugging
  // lv_log_register_print_cb(log_print);

  // // Start the SPI for the touchscreen and init the touchscreen
  // touchscreenSPI.begin(XPT2046_CLK, XPT2046_MISO, XPT2046_MOSI, XPT2046_CS);
  // touchscreen.begin(touchscreenSPI);
  // // Set the Touchscreen rotation in landscape mode
  // Note: in some displays, the touchscreen might be upside down, so you might need to set the rotation to 0: touchscreen.setRotation(0);
  // touchscreen.setRotation(2);

  // Create a display object
  lv_display_t *disp;
  // Initialize the TFT display using the TFT_eSPI library
  disp = lv_tft_espi_create(SCREEN_WIDTH, SCREEN_HEIGHT, draw_buf, sizeof(draw_buf));
  lv_display_set_rotation(disp, LV_DISPLAY_ROTATION_270);

  // Initialize an LVGL input device object (Touchscreen)
  lv_indev_t *indev = lv_indev_create();
  lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);
  // Set the callback function to read Touchscreen input
  lv_indev_set_read_cb(indev, touchscreen_read);
  // static lv_indev_drv_t indev_drv;
  // lv_indev_drv_init(&indev_drv);
  // indev_drv.type = LV_INDEV_TYPE_POINTER;
  // indev_drv.read_cb = touchscreen_read;
  // lv_indev_drv_register(&indev_drv);

  // Function to draw the GUI (text, buttons and sliders)
  lv_create_main_gui();
}

void loop()
{
  lv_task_handler(); // let the GUI do its work
  lv_tick_inc(5);    // tell LVGL how much time has passed
  delay(5);          // let this time pass
}
